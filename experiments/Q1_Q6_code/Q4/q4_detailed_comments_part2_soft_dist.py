#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ============================================================================
# Q4 长上下文位置漂移分析脚本 - 详细注释补充（第2部分）
# 分布构建：Soft 分布和 Hard 分布
# ============================================================================

"""
========================================================================
本部分解释如何从窗口内的 token 构建专家使用分布
========================================================================
"""

# ============================================================================
# 核心函数：build_soft_distribution（软分布构建）
# ============================================================================
def build_soft_distribution(
    probs_window: np.ndarray,
    idx_window: np.ndarray,
    n_experts: int,
) -> np.ndarray:
    """
    ========================================================================
    函数功能：构建窗口内的"软分布"（概率累加 + Other 桶）
    ========================================================================

    【什么是软分布？】
    考虑 Top-K 的所有专家及其概率，而不是只看 Top-1。

    【为什么需要 Other 桶？】
    因为我们只记录了 Top-K（例如 Top-6）的专家，
    剩余的 54 个专家的概率被合并到 "Other" 桶中。

    【给零基础同学的解释】：
    想象你要统计一个班级（60人）的考试成绩分布：
    - 你只记录了前6名的详细分数
    - 其余54人的分数合并成"其他"

    软分布就是：
    - 前6名：每人的具体分数
    - 其他54人：总分数

    【数学公式】：
    Soft_Distribution[e] = Σ_{t∈window} P_t(e) / |window|

    其中：
    - P_t(e)：token t 选择专家 e 的概率
    - |window|：窗口大小（token 数量）

    【Other 桶的计算】：
    Other = 1 - Σ_{e∈Top-K} P(e)

    【示例】：
    假设窗口有 3 个 token，60 个专家，Top-3：

    Token 0：专家5(0.6), 专家8(0.3), 专家12(0.1)
    Token 1：专家5(0.5), 专家12(0.3), 专家20(0.2)
    Token 2：专家8(0.7), 专家5(0.2), 专家12(0.1)

    累加后：
    - 专家5：(0.6 + 0.5 + 0.2) / 3 = 1.3 / 3 ≈ 0.433
    - 专家8：(0.3 + 0 + 0.7) / 3 = 1.0 / 3 ≈ 0.333
    - 专家12：(0.1 + 0.3 + 0.1) / 3 = 0.5 / 3 ≈ 0.167
    - 专家20：(0 + 0.2 + 0) / 3 = 0.2 / 3 ≈ 0.067
    - Other：0（因为 Top-3 概率和为1）

    【参数说明】：
    - probs_window: np.ndarray，窗口内所有 token 的 Top-K 概率
      shape: (window_size, K)
    - idx_window: np.ndarray，窗口内所有 token 的 Top-K 专家索引
      shape: (window_size, K)
    - n_experts: int，专家总数（例如 60）

    【返回值】：
    - np.ndarray，软分布，shape: (n_experts + 1,)
      最后一个元素是 Other 桶
    """
    # ====================================================================
    # 步骤1：初始化分布向量（60 专家 + 1 Other）
    # ====================================================================
    """
    【数据结构】：
    full = np.zeros(n_experts + 1, dtype=np.float64)

    【为什么是 n_experts + 1？】
    - 前 n_experts 个位置：每个专家的概率
    - 最后 1 个位置：Other 桶

    【给零基础同学的解释】：
    想象你要准备一个表格：
    - 前60列：每个学生的分数
    - 第61列："其他"学生的总分
    """
    full = np.zeros(n_experts + 1, dtype=np.float64)

    # ====================================================================
    # 步骤2：遍历窗口内每个 token
    # ====================================================================
    """
    【循环逻辑】：
    for t in range(probs_window.shape[0]):
        # 处理第 t 个 token

    【给零基础同学的解释】：
    想象你要统计每个学生的选课情况：
    - 学生1：选了数学、物理、化学
    - 学生2：选了物理、化学、生物
    - ...

    遍历每个学生，累加他们的选课。
    """
    for t in range(probs_window.shape[0]):
        p = probs_window[t]  # 该 token 的 Top-K 概率
        idx = idx_window[t]  # 该 token 的 Top-K 专家索引

        # ================================================================
        # 步骤2.1：计算剩余概率（Other 桶）
        # ================================================================
        """
        【剩余概率计算】：
        residual = max(0.0, 1.0 - prob_sum)

        【为什么要用 max(0.0, ...)?】
        因为由于浮点数精度问题，prob_sum 可能略大于 1.0。

        【示例】：
        情况1（正常）：
        - Top-3 概率：[0.6, 0.3, 0.05]
        - prob_sum = 0.95
        - residual = 1.0 - 0.95 = 0.05（剩余5%给 Other）

        情况2（浮点数误差）：
        - Top-3 概率：[0.6, 0.3, 0.1000001]
        - prob_sum = 1.0000001
        - residual = max(0.0, 1.0 - 1.0000001) = 0（避免负数）

        【给零基础同学的解释】：
        想象你要分配100%的时间：
        - 前3个任务占了95%的时间
        - 剩余5%的时间给"其他任务"
        """
        prob_sum = float(np.sum(p))
        residual = max(0.0, 1.0 - prob_sum)

        # ================================================================
        # 步骤2.2：累加 Top-K 概率到对应专家
        # ================================================================
        """
        【累加逻辑】：
        for k in range(len(p)):
            expert_id = int(idx[k])
            if 0 <= expert_id < n_experts:
                full[expert_id] += float(p[k])

        【示例】：
        假设 token 0 的 Top-3：
        - k=0：专家5，概率0.6 → full[5] += 0.6
        - k=1：专家8，概率0.3 → full[8] += 0.3
        - k=2：专家12，概率0.1 → full[12] += 0.1

        【为什么要检查 0 <= expert_id < n_experts？】
        防止无效的专家索引（例如 -1）。

        【给零基础同学的解释】：
        想象你要统计每个演员的出场时间：
        - 演员5：出场0.6小时
        - 演员8：出场0.3小时
        - 演员12：出场0.1小时

        累加到总时间表中。
        """
        for k in range(len(p)):
            expert_id = int(idx[k])
            if 0 <= expert_id < n_experts:
                full[expert_id] += float(p[k])

        # ================================================================
        # 步骤2.3：累加剩余概率到 Other 桶
        # ================================================================
        """
        【Other 桶累加】：
        full[-1] += residual

        【full[-1] 的含义】：
        Python 的负索引：-1 表示最后一个元素。

        【给零基础同学的解释】：
        想象你要把"其他任务"的时间累加到表格的最后一列。
        """
        full[-1] += residual

    # ====================================================================
    # 步骤3：归一化成平均分布
    # ====================================================================
    """
    【为什么要归一化？】
    因为我们累加了窗口内所有 token 的概率，
    需要除以 token 数量得到平均分布。

    【数学公式】：
    Soft_Distribution = Σ P_t / |window|

    【给零基础同学的解释】：
    想象你统计了3个学生的选课情况：
    - 数学：3次
    - 物理：2次
    - 化学：1次

    平均每个学生：
    - 数学：3/3 = 1次
    - 物理：2/3 ≈ 0.67次
    - 化学：1/3 ≈ 0.33次
    """
    return _safe_normalize(full)


# ============================================================================
# 第2部分完成
# ============================================================================
# 下一部分将包含：
# - build_hard_distribution：硬分布构建（Top-1 频次）
# - 窗口划分函数
# - 曲线重采样函数
# ============================================================================
