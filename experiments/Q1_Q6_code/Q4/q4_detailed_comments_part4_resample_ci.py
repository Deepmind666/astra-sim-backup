#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ============================================================================
# Q4 长上下文位置漂移分析脚本 - 详细注释补充（第4部分）
# 曲线重采样、置信区间计算
# ============================================================================

"""
========================================================================
本部分包含 Q4 的辅助函数：
1. resample_curve：曲线重采样（线性插值）
2. mean_ci：计算均值和置信区间
========================================================================
"""

# ============================================================================
# 辅助函数：resample_curve（曲线重采样）
# ============================================================================
def resample_curve(curve: List[float], target_len: int) -> List[float]:
    """
    ========================================================================
    函数功能：把不同长度的曲线统一重采样到固定长度
    ========================================================================

    【什么是曲线重采样？】
    把不同长度的曲线（例如有的3个点，有的5个点）统一到相同长度，
    便于跨样本平均和可视化。

    【给零基础同学的解释】：
    想象你要比较不同学生的成绩变化趋势：
    - 学生A：考了3次试，成绩 [80, 85, 90]
    - 学生B：考了5次试，成绩 [75, 78, 82, 85, 88]

    如何比较他们的"平均趋势"？
    → 把两条曲线都重采样到相同长度（例如10个点），然后取平均。

    【为什么需要重采样？】
    1. 不同样本的窗口数量不同（序列长度不同）
    2. 需要计算"平均漂移曲线"
    3. 需要统一横坐标进行可视化

    【重采样方法：线性插值】
    使用线性插值（Linear Interpolation）在新位置估计值。

    【数学原理】：
    1. 把原始曲线的横坐标归一化到 [0, 1]
    2. 把目标曲线的横坐标也归一化到 [0, 1]
    3. 在新位置用线性插值估计值

    【示例】：
    假设原始曲线有 3 个点：
    curve = [0.2, 0.5, 0.8]

    目标长度 target_len = 5

    【逐步计算】：
    1. 原始横坐标（归一化到 [0, 1]）：
       x_old = [0.0, 0.5, 1.0]
       （3个点均匀分布在 [0, 1] 区间）

    2. 目标横坐标（归一化到 [0, 1]）：
       x_new = [0.0, 0.25, 0.5, 0.75, 1.0]
       （5个点均匀分布在 [0, 1] 区间）

    3. 线性插值：
       - x_new[0] = 0.0 → 对应 x_old[0] → y = 0.2
       - x_new[1] = 0.25 → 在 x_old[0] 和 x_old[1] 之间
         * 插值：y = 0.2 + (0.5-0.2) * (0.25-0.0)/(0.5-0.0)
         * y = 0.2 + 0.3 * 0.5 = 0.35
       - x_new[2] = 0.5 → 对应 x_old[1] → y = 0.5
       - x_new[3] = 0.75 → 在 x_old[1] 和 x_old[2] 之间
         * 插值：y = 0.5 + (0.8-0.5) * (0.75-0.5)/(1.0-0.5)
         * y = 0.5 + 0.3 * 0.5 = 0.65
       - x_new[4] = 1.0 → 对应 x_old[2] → y = 0.8

    4. 重采样结果：
       [0.2, 0.35, 0.5, 0.65, 0.8]

    【给零基础同学的解释】：
    想象你要把一条折线图从3个点扩展到5个点：
    - 原来：在位置 [0%, 50%, 100%] 有3个点
    - 现在：要在位置 [0%, 25%, 50%, 75%, 100%] 有5个点
    - 新增的点（25%, 75%）用"连线"估计出来

    【参数说明】：
    - curve: List[float]，原始曲线（任意长度）
    - target_len: int，目标长度

    【返回值】：
    - List[float]，重采样后的曲线（长度为 target_len）

    【边界情况处理】：
    1. 空曲线：返回全0数组
    2. 单点曲线：返回全部相同的值
    """
    # ====================================================================
    # 边界情况1：空曲线
    # ====================================================================
    """
    【空曲线处理】：
    if len(curve) == 0:
        return [0.0] * target_len

    【为什么返回全0？】
    因为没有数据，无法插值，返回默认值0。

    【示例】：
    curve = []
    target_len = 5
    返回：[0.0, 0.0, 0.0, 0.0, 0.0]

    【给零基础同学的解释】：
    想象你要画一条曲线，但没有任何数据点：
    → 只能画一条水平线（值为0）
    """
    if len(curve) == 0:
        return [0.0] * target_len

    # ====================================================================
    # 边界情况2：单点曲线
    # ====================================================================
    """
    【单点曲线处理】：
    if len(curve) == 1:
        return [curve[0]] * target_len

    【为什么返回相同值？】
    因为只有一个点，无法插值，只能用这个值填充。

    【示例】：
    curve = [0.5]
    target_len = 5
    返回：[0.5, 0.5, 0.5, 0.5, 0.5]

    【给零基础同学的解释】：
    想象你只有一个数据点（例如"第1次考试85分"）：
    → 无法预测趋势，只能假设"一直是85分"
    """
    if len(curve) == 1:
        return [curve[0]] * target_len

    # ====================================================================
    # 步骤1：生成原始横坐标（归一化到 [0, 1]）
    # ====================================================================
    """
    【生成横坐标】：
    x_old = np.linspace(0.0, 1.0, num=len(curve))

    【np.linspace 的作用】：
    在 [0, 1] 区间生成 len(curve) 个均匀分布的点。

    【示例】：
    len(curve) = 3
    x_old = np.linspace(0.0, 1.0, num=3)
    x_old = [0.0, 0.5, 1.0]

    len(curve) = 5
    x_old = np.linspace(0.0, 1.0, num=5)
    x_old = [0.0, 0.25, 0.5, 0.75, 1.0]

    【给零基础同学的解释】：
    想象你要在一条线段上均匀放置几个点：
    - 线段长度：从0到1
    - 放3个点：在 0%, 50%, 100% 的位置
    - 放5个点：在 0%, 25%, 50%, 75%, 100% 的位置
    """
    x_old = np.linspace(0.0, 1.0, num=len(curve))

    # ====================================================================
    # 步骤2：生成目标横坐标（归一化到 [0, 1]）
    # ====================================================================
    """
    【生成目标横坐标】：
    x_new = np.linspace(0.0, 1.0, num=target_len)

    【示例】：
    target_len = 5
    x_new = [0.0, 0.25, 0.5, 0.75, 1.0]

    target_len = 10
    x_new = [0.0, 0.111, 0.222, ..., 1.0]

    【给零基础同学的解释】：
    想象你要在同一条线段上放置更多（或更少）的点：
    - 原来3个点：[0%, 50%, 100%]
    - 现在5个点：[0%, 25%, 50%, 75%, 100%]
    """
    x_new = np.linspace(0.0, 1.0, num=target_len)

    # ====================================================================
    # 步骤3：线性插值
    # ====================================================================
    """
    【线性插值】：
    y_new = np.interp(x_new, x_old, np.array(curve, dtype=np.float64))

    【np.interp 的作用】：
    在新横坐标 x_new 上，根据旧横坐标 x_old 和旧纵坐标 curve，
    用线性插值计算新纵坐标。

    【参数说明】：
    - x_new：新横坐标（要插值的位置）
    - x_old：旧横坐标（已知点的位置）
    - curve：旧纵坐标（已知点的值）

    【线性插值公式】：
    假设要在 x 位置插值，x 在 x_old[i] 和 x_old[i+1] 之间：

    y = y_old[i] + (y_old[i+1] - y_old[i]) * (x - x_old[i]) / (x_old[i+1] - x_old[i])

    【示例】：
    x_old = [0.0, 0.5, 1.0]
    curve = [0.2, 0.5, 0.8]
    x_new = [0.0, 0.25, 0.5, 0.75, 1.0]

    插值计算：
    - x_new[0] = 0.0 → 直接对应 x_old[0] → y = 0.2
    - x_new[1] = 0.25 → 在 [0.0, 0.5] 之间
      * y = 0.2 + (0.5-0.2) * (0.25-0.0)/(0.5-0.0)
      * y = 0.2 + 0.3 * 0.5 = 0.35
    - x_new[2] = 0.5 → 直接对应 x_old[1] → y = 0.5
    - x_new[3] = 0.75 → 在 [0.5, 1.0] 之间
      * y = 0.5 + (0.8-0.5) * (0.75-0.5)/(1.0-0.5)
      * y = 0.5 + 0.3 * 0.5 = 0.65
    - x_new[4] = 1.0 → 直接对应 x_old[2] → y = 0.8

    结果：[0.2, 0.35, 0.5, 0.65, 0.8]

    【给零基础同学的解释】：
    想象你要在两个已知点之间估计新点的值：
    - 已知：0%位置值为0.2，50%位置值为0.5
    - 要估计：25%位置的值
    - 方法：画一条直线连接两个已知点，看25%位置在直线上的值
    """
    y_new = np.interp(x_new, x_old, np.array(curve, dtype=np.float64))

    # ====================================================================
    # 步骤4：转换为列表返回
    # ====================================================================
    """
    【转换为列表】：
    return y_new.tolist()

    【为什么要转换？】
    因为函数签名要求返回 List[float]，而 np.interp 返回 np.ndarray。

    【给零基础同学的解释】：
    想象你用计算器算出了一组数字，现在要写在纸上：
    → 把计算器的结果转换成纸上的列表
    """
    return y_new.tolist()


# ============================================================================
# 辅助函数：mean_ci（均值和置信区间）
# ============================================================================
def mean_ci(curves: List[List[float]]) -> Tuple[List[float], List[float]]:
    """
    ========================================================================
    函数功能：计算多条曲线的均值和 95% 置信区间
    ========================================================================

    【什么是置信区间？】
    置信区间表示"均值的不确定性范围"。

    【给零基础同学的解释】：
    想象你要统计"学生的平均成绩"：
    - 如果只有3个学生：[80, 85, 90]，平均85分
    - 如果有100个学生：平均85分

    哪个"85分"更可靠？
    → 100个学生的平均更可靠（置信区间更窄）

    置信区间就是"平均值 ± 误差范围"：
    - 3个学生：85 ± 10分（不太确定）
    - 100个学生：85 ± 2分（很确定）

    【数学公式】：
    95% 置信区间 = 1.96 * SEM

    其中：
    - SEM（Standard Error of Mean）：均值的标准误差
    - SEM = SD / sqrt(N)
    - SD：标准差（Standard Deviation）
    - N：样本数量

    【为什么是 1.96？】
    因为在正态分布下，95% 的数据落在"均值 ± 1.96*SEM"范围内。

    【示例】：
    假设有 3 条曲线（3个样本），每条曲线有 4 个点：

    曲线1：[0.2, 0.3, 0.5, 0.7]
    曲线2：[0.3, 0.4, 0.6, 0.8]
    曲线3：[0.1, 0.2, 0.4, 0.6]

    【逐步计算】：
    1. 转换为数组：
       arr = [[0.2, 0.3, 0.5, 0.7],
              [0.3, 0.4, 0.6, 0.8],
              [0.1, 0.2, 0.4, 0.6]]

    2. 计算每个位置的均值（按列）：
       位置0：(0.2 + 0.3 + 0.1) / 3 = 0.2
       位置1：(0.3 + 0.4 + 0.2) / 3 = 0.3
       位置2：(0.5 + 0.6 + 0.4) / 3 = 0.5
       位置3：(0.7 + 0.8 + 0.6) / 3 = 0.7
       mean = [0.2, 0.3, 0.5, 0.7]

    3. 计算每个位置的标准差（按列）：
       位置0：sqrt(((0.2-0.2)² + (0.3-0.2)² + (0.1-0.2)²) / 2)
            = sqrt((0 + 0.01 + 0.01) / 2) = sqrt(0.01) = 0.1
       位置1：同理，SD ≈ 0.1
       位置2：同理，SD ≈ 0.1
       位置3：同理，SD ≈ 0.1
       SD = [0.1, 0.1, 0.1, 0.1]

    4. 计算 SEM：
       SEM = SD / sqrt(N) = 0.1 / sqrt(3) ≈ 0.058
       SEM = [0.058, 0.058, 0.058, 0.058]

    5. 计算置信区间：
       CI = 1.96 * SEM = 1.96 * 0.058 ≈ 0.114
       CI = [0.114, 0.114, 0.114, 0.114]

    【结果解释】：
    - 均值：[0.2, 0.3, 0.5, 0.7]
    - 置信区间：[0.114, 0.114, 0.114, 0.114]
    - 意思：在位置0，真实均值有95%的概率在 0.2 ± 0.114 范围内

    【给零基础同学的解释】：
    想象你要统计"学生在不同时间的平均成绩"：
    - 第1次考试：平均80分 ± 5分（置信区间）
    - 第2次考试：平均85分 ± 3分
    - 第3次考试：平均90分 ± 4分

    置信区间越小，说明"这次平均分"越可靠。

    【参数说明】：
    - curves: List[List[float]]，多条曲线
      * 每条曲线是一个样本
      * 所有曲线长度必须相同（通常已经过 resample_curve）

    【返回值】：
    - Tuple[List[float], List[float]]
      * 第一个列表：均值曲线
      * 第二个列表：置信区间（半宽）
    """
    # ====================================================================
    # 边界情况：空列表
    # ====================================================================
    """
    【空列表处理】：
    if not curves:
        return [], []

    【为什么返回空列表？】
    因为没有数据，无法计算均值和置信区间。

    【给零基础同学的解释】：
    想象你要统计学生的平均成绩，但没有任何学生：
    → 无法计算，返回空结果
    """
    if not curves:
        return [], []

    # ====================================================================
    # 步骤1：转换为 NumPy 数组
    # ====================================================================
    """
    【转换为数组】：
    arr = np.array(curves, dtype=np.float64)

    【为什么要转换？】
    因为 NumPy 数组支持高效的矩阵运算（按列求均值、标准差）。

    【示例】：
    curves = [[0.2, 0.3, 0.5, 0.7],
              [0.3, 0.4, 0.6, 0.8],
              [0.1, 0.2, 0.4, 0.6]]

    arr = array([[0.2, 0.3, 0.5, 0.7],
                 [0.3, 0.4, 0.6, 0.8],
                 [0.1, 0.2, 0.4, 0.6]])

    形状：(3, 4)（3个样本，每个4个点）

    【给零基础同学的解释】：
    想象你要把多个学生的成绩列表整理成一张表格：
    - 学生A：[80, 85, 90, 95]
    - 学生B：[75, 80, 85, 90]
    - 学生C：[85, 90, 95, 100]
    → 表格有3行4列
    """
    arr = np.array(curves, dtype=np.float64)

    # ====================================================================
    # 步骤2：计算均值（按列）
    # ====================================================================
    """
    【计算均值】：
    mean = np.mean(arr, axis=0)

    【axis=0 的含义】：
    按列计算（对每个位置，计算所有样本的平均值）。

    【示例】：
    arr = [[0.2, 0.3, 0.5, 0.7],
           [0.3, 0.4, 0.6, 0.8],
           [0.1, 0.2, 0.4, 0.6]]

    mean = np.mean(arr, axis=0)
    mean = [(0.2+0.3+0.1)/3, (0.3+0.4+0.2)/3, (0.5+0.6+0.4)/3, (0.7+0.8+0.6)/3]
    mean = [0.2, 0.3, 0.5, 0.7]

    【给零基础同学的解释】：
    想象你要计算每次考试的平均分：
    - 第1次考试：(80+75+85)/3 = 80分
    - 第2次考试：(85+80+90)/3 = 85分
    - 第3次考试：(90+85+95)/3 = 90分
    - 第4次考试：(95+90+100)/3 = 95分
    """
    mean = np.mean(arr, axis=0)

    # ====================================================================
    # 步骤3：计算标准误差（SEM）
    # ====================================================================
    """
    【计算 SEM】：
    sem = np.std(arr, axis=0, ddof=1) / math.sqrt(arr.shape[0])

    【逐步拆解】：
    1. np.std(arr, axis=0, ddof=1)：计算标准差（按列）
       - axis=0：按列计算
       - ddof=1：自由度修正（样本标准差）

    2. arr.shape[0]：样本数量（行数）

    3. math.sqrt(arr.shape[0])：样本数量的平方根

    4. SD / sqrt(N)：标准误差公式

    【ddof=1 的含义】：
    使用样本标准差（除以 N-1）而不是总体标准差（除以 N）。

    【为什么要除以 sqrt(N)？】
    因为均值的标准误差 = 标准差 / sqrt(样本数量)。

    【示例】：
    arr.shape[0] = 3（3个样本）
    SD = [0.1, 0.1, 0.1, 0.1]
    SEM = 0.1 / sqrt(3) ≈ 0.058

    【边界情况】：
    if arr.shape[0] > 1:
        sem = SD / sqrt(N)
    else:
        sem = 0（只有1个样本，无法计算标准误差）

    【给零基础同学的解释】：
    想象你要估计"平均分的误差"：
    - 如果只有1个学生：无法估计误差
    - 如果有3个学生：误差 = 标准差 / sqrt(3)
    - 如果有100个学生：误差 = 标准差 / sqrt(100)（误差更小）
    """
    sem = np.std(arr, axis=0, ddof=1) / math.sqrt(arr.shape[0]) if arr.shape[0] > 1 else np.zeros_like(mean)

    # ====================================================================
    # 步骤4：计算置信区间
    # ====================================================================
    """
    【计算置信区间】：
    ci = 1.96 * sem

    【为什么是 1.96？】
    因为在正态分布下，95% 的数据落在"均值 ± 1.96*SEM"范围内。

    【示例】：
    sem = [0.058, 0.058, 0.058, 0.058]
    ci = 1.96 * 0.058 ≈ [0.114, 0.114, 0.114, 0.114]

    【给零基础同学的解释】：
    想象你要画"误差棒"：
    - 均值：80分
    - 置信区间：±5分
    - 意思：真实平均分有95%的概率在 75-85分 之间
    """
    ci = 1.96 * sem

    # ====================================================================
    # 步骤5：转换为列表返回
    # ====================================================================
    """
    【转换为列表】：
    return mean.tolist(), ci.tolist()

    【返回值】：
    - mean.tolist()：均值曲线（列表）
    - ci.tolist()：置信区间（列表）

    【给零基础同学的解释】：
    想象你要报告统计结果：
    - 均值：[80, 85, 90, 95]
    - 置信区间：[5, 3, 4, 2]
    - 意思：第1次考试平均80±5分，第2次考试平均85±3分，...
    """
    return mean.tolist(), ci.tolist()


# ============================================================================
# Q4 Part 4 完成
# ============================================================================
# 下一部分将包含：
# - 边界检测函数的详细注释
# - 伪边界构造的详细注释
# - 主分析流程的详细注释
# ============================================================================
