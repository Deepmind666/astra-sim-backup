#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ============================================================================
# Q4 长上下文位置漂移分析脚本 - 详细注释补充（第1部分）
# 核心数学函数：JSD、TV、熵
# ============================================================================

"""
========================================================================
Q4 核心问题：长序列上的专家路由是否随位置漂移？
========================================================================

【研究背景】：
在长文本处理中，模型需要处理数千个 token。
问题：专家路由分布是否会随着位置变化而漂移？

【给零基础同学的解释】：
想象你在看一部长电影（2小时）：
- 前30分钟：主要是演员A和B出场
- 中间60分钟：主要是演员C和D出场
- 后30分钟：又回到演员A和B

这种"演员出场分布随时间变化"就是"位置漂移"。

【核心指标】：
1. JSD（Jensen-Shannon Divergence）：衡量分布差异
2. TV（Total Variation Distance）：衡量概率质量移动
3. 熵（Entropy）：衡量不确定性

【分析方法】：
1. 把长序列切成多个窗口（例如每128个token一个窗口）
2. 计算相邻窗口之间的分布差异（JSD/TV）
3. 观察差异是否随位置变化
"""

# ============================================================================
# 核心函数：_safe_normalize（安全归一化）
# ============================================================================
def _safe_normalize(vec: np.ndarray) -> np.ndarray:
    """
    ========================================================================
    函数功能：将向量归一化为概率分布（和为1）
    ========================================================================

    【为什么需要"安全"归一化？】
    因为可能遇到特殊情况：
    1. 向量全为0（无法归一化）
    2. 向量包含负数（不是有效概率）

    【给零基础同学的解释】：
    想象你要把一堆数字转换成百分比：
    - 正常情况：[2, 3, 5] → [20%, 30%, 50%]（和为100%）
    - 特殊情况：[0, 0, 0] → 无法计算百分比

    "安全"归一化就是处理这些特殊情况。

    【数学公式】：
    正常情况：P(i) = vec(i) / Σ vec(j)
    特殊情况：P(i) = 1 / N（均匀分布）

    【参数说明】：
    - vec: np.ndarray，输入向量

    【返回值】：
    - np.ndarray，归一化后的概率分布（和为1）
    """
    total = float(np.sum(vec))

    if total <= 0:
        # 如果总和为0或负数，返回均匀分布
        return np.ones_like(vec, dtype=np.float64) / float(len(vec))

    return vec.astype(np.float64) / total


# ============================================================================
# 核心函数：jsd（Jensen-Shannon Divergence）
# ============================================================================
def jsd(p: np.ndarray, q: np.ndarray, eps: float = 1e-12) -> float:
    """
    ========================================================================
    函数功能：计算两个概率分布之间的 JSD
    ========================================================================

    【JSD 在 Q4 中的作用】：
    衡量"相邻窗口的专家分布有多不同"。

    【给零基础同学的解释】：
    想象你要比较电影的两个片段：
    - 片段1（前30分钟）：演员A出场60%，演员B出场40%
    - 片段2（中30分钟）：演员A出场20%，演员B出场80%

    JSD 就是衡量"这两个片段的演员分布有多不同"。

    【数学公式】：
    JSD(P||Q) = 0.5 * KL(P||M) + 0.5 * KL(Q||M)
    其中 M = 0.5 * (P + Q)

    【详细推导请参考 Q2 的注释】

    【参数说明】：
    - p: np.ndarray，第一个窗口的专家分布
    - q: np.ndarray，第二个窗口的专家分布
    - eps: float，防止 log(0) 的小常数

    【返回值】：
    - float，JSD 值，范围 [0, 1]
    """
    p = np.asarray(p, dtype=np.float64)
    q = np.asarray(q, dtype=np.float64)

    # 截断并归一化
    p = np.clip(p, eps, 1.0)
    q = np.clip(q, eps, 1.0)
    p = _safe_normalize(p)
    q = _safe_normalize(q)

    # 计算中间分布
    m = 0.5 * (p + q)

    # KL 散度
    def _kl(a: np.ndarray, b: np.ndarray) -> float:
        return float(np.sum(a * (np.log2(a) - np.log2(b))))

    return 0.5 * _kl(p, m) + 0.5 * _kl(q, m)


# ============================================================================
# 核心函数：tv（Total Variation Distance）
# ============================================================================
def tv(p: np.ndarray, q: np.ndarray) -> float:
    """
    ========================================================================
    函数功能：计算两个概率分布之间的 TV 距离
    ========================================================================

    【TV 在 Q4 中的作用】：
    另一种衡量"相邻窗口分布差异"的指标。

    【数学公式】：
    TV(P, Q) = 0.5 * Σ |P(i) - Q(i)|

    【详细推导请参考 Q2 的注释】

    【参数说明】：
    - p: np.ndarray，第一个窗口的专家分布
    - q: np.ndarray，第二个窗口的专家分布

    【返回值】：
    - float，TV 距离，范围 [0, 1]
    """
    p = _safe_normalize(p)
    q = _safe_normalize(q)
    return 0.5 * float(np.sum(np.abs(p - q)))


# ============================================================================
# 核心函数：entropy（熵）
# ============================================================================
def entropy(p: np.ndarray, eps: float = 1e-12) -> float:
    """
    ========================================================================
    函数功能：计算概率分布的熵
    ========================================================================

    【熵在 Q4 中的作用】：
    观察"专家选择的不确定性"是否随位置变化。

    【给零基础同学的解释】：
    想象你要猜测下一个出场的演员：
    - 如果只有1个演员频繁出场：很容易猜（熵低）
    - 如果10个演员平均出场：很难猜（熵高）

    【数学公式】：
    H(p) = -Σ p(i) * log2(p(i))

    【公式详解】：
    假设有3个专家：

    情况1（低熵）：
    p = [0.9, 0.05, 0.05]
    H(p) = -(0.9*log2(0.9) + 0.05*log2(0.05) + 0.05*log2(0.05))
    H(p) ≈ 0.57 bits

    情况2（高熵）：
    p = [0.33, 0.33, 0.34]
    H(p) = -(0.33*log2(0.33) + 0.33*log2(0.33) + 0.34*log2(0.34))
    H(p) ≈ 1.58 bits

    【结果解释】：
    - 熵低：分布集中，不确定性小
    - 熵高：分布均匀，不确定性大

    【参数说明】：
    - p: np.ndarray，概率分布
    - eps: float，防止 log(0) 的小常数

    【返回值】：
    - float，熵值（单位：bits）
    """
    p = np.asarray(p, dtype=np.float64)
    p = np.clip(p, eps, 1.0)
    p = _safe_normalize(p)
    return float(-np.sum(p * np.log2(p)))


# ============================================================================
# 第1部分完成
# ============================================================================
# 下一部分将包含：
# - build_soft_distribution：软分布构建（含 Other 桶）
# - build_hard_distribution：硬分布构建（Top-1 频次）
# - 窗口划分和曲线重采样
# ============================================================================
