#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ============================================================================
# Q2 任务偏好分析脚本 - 详细注释补充（第5部分 - 最终部分）
# Soft 口径的实现和向量归一化
# ============================================================================

"""
========================================================================
本部分完成 build_token_vectors 函数的剩余部分
========================================================================
"""

        # ================================================================
        # 步骤2.7：Soft 口径累加（考虑 Top-(K+2) 的概率）
        # ================================================================
        """
        【Soft 口径的核心逻辑】：
        遍历 Top-(K+2) 的所有专家，按概率累加。

        【为什么叫 Soft？】
        因为不是"硬性"只选 Top-1，而是"软性"考虑多个候选专家。

        【代码详解】：
        for col in range(inds.shape[1]):
            # 遍历 Top-(K+2) 的每一列

        【示例】：
        假设 K=2，则 Top-(K+2) = Top-4
        inds.shape[1] = 4（4列）
        - col=0：Top-1 专家
        - col=1：Top-2 专家
        - col=2：Top-3 专家
        - col=3：Top-4 专家

        【给零基础同学的解释】：
        想象你要统计学生的选修课：
        - 学生A：主修数学（权重0.6），选修物理（权重0.3），选修化学（权重0.1）
        - 遍历每门课，按权重累加
        """
        for col in range(inds.shape[1]):  # 遍历 Top-(K+2)
            # ============================================================
            # 步骤2.7.1：检查该列是否有效
            # ============================================================
            """
            【有效性检查】：
            valid = inds[:, col] >= 0

            【为什么要检查？】
            因为某些 token 可能没有足够的候选专家：
            - 如果只有 2 个专家被激活，但我们要 Top-4
            - 那么第3、4列会被填充为 -1（无效）

            【示例】：
            inds = array([[5, 8, 12, -1],   # token 0 只有3个有效专家
                          [12, 5, 20, 30],  # token 1 有4个有效专家
                          [8, -1, -1, -1]]) # token 2 只有1个有效专家

            col=0: valid = [True, True, True]（都有效）
            col=1: valid = [True, True, False]（token 2 无效）
            col=2: valid = [True, True, False]
            col=3: valid = [False, True, False]

            【给零基础同学的解释】：
            想象你要统计选修课：
            - 有的学生选了4门选修课
            - 有的学生只选了2门选修课
            - 需要检查"该学生是否选了第N门选修课"
            """
            valid = inds[:, col] >= 0  # 合法标记
            if not np.any(valid):  # 如果没有合法的
                continue  # 跳过该列

            # ============================================================
            # 步骤2.7.2：累加概率到对应专家
            # ============================================================
            """
            【Soft 累加】：
            np.add.at(soft_vecs, (行索引, 列索引), 概率)

            【代码详解】：
            np.add.at(
                soft_vecs,
                (np.arange(n_tokens)[valid], inds[valid, col]),
                probs_norm[valid, col]
            )

            【逐步拆解】：
            1. np.arange(n_tokens)[valid]：有效 token 的行索引
            2. inds[valid, col]：有效 token 在该列的专家索引
            3. probs_norm[valid, col]：有效 token 在该列的概率

            【示例】：
            假设 col=1（Top-2 专家）：
            - token 0：专家8，概率0.3
            - token 1：专家5，概率0.3
            - token 2：无效（-1）

            执行：
            np.add.at(soft_vecs, ([0, 1], [8, 5]), [0.3, 0.3])

            结果：
            soft_vecs[0, 8] += 0.3  # token 0 给专家8累加0.3
            soft_vecs[1, 5] += 0.3  # token 1 给专家5累加0.3

            【给零基础同学的解释】：
            想象你要统计选修课的加权分数：
            - 学生A选修物理，权重0.3 → 物理 +0.3 分
            - 学生B选修数学，权重0.3 → 数学 +0.3 分

            【Soft vs Hard 的对比】：
            Hard：只给 Top-1 投票（0或1）
            Soft：给所有候选按概率投票（0到1之间的小数）
            """
            np.add.at(
                soft_vecs,
                (np.arange(n_tokens)[valid], inds[valid, col]),
                probs_norm[valid, col]
            )  # Soft 累加

    # ====================================================================
    # 步骤3：归一化（除以层数）
    # ====================================================================
    """
    【为什么要除以层数？】
    因为我们累加了所有层的投票，需要取平均。

    【数学公式】：
    Hard_final = Hard_sum / L
    Soft_final = Soft_sum / L

    其中 L 是层数。

    【示例】：
    假设有 3 层，某个 token 的累加结果：
    - 专家5：在3层中被选为 Top-1 两次
    - hard_vecs[token, 5] = 2.0

    归一化后：
    - hard_vecs[token, 5] = 2.0 / 3 ≈ 0.667

    【结果解释】：
    0.667 表示"该 token 在 66.7% 的层中选择了专家5"。

    【给零基础同学的解释】：
    想象你要统计学生的平均选课情况：
    - 3个学期，学生A选了2次数学
    - 平均：2 / 3 ≈ 0.667（66.7% 的学期选了数学）
    """
    hard_vecs /= float(n_layers)  # 对层取平均
    soft_vecs /= float(n_layers)  # 对层取平均

    # ====================================================================
    # 步骤4：整理置信度统计
    # ====================================================================
    """
    【置信度统计】：
    返回 3 个指标的 token 级均值：
    1. top1_prob：Top-1 概率的平均值
    2. margin：Margin 的平均值
    3. entropy：熵的平均值

    【为什么要取平均？】
    因为每个 token 在每层都有这些统计量，我们需要汇总。

    【示例】：
    某个 token 在 3 层的 Top-1 概率：
    - 层1：0.6
    - 层2：0.5
    - 层3：0.7

    平均：(0.6 + 0.5 + 0.7) / 3 = 0.6

    【给零基础同学的解释】：
    想象你要统计学生的平均最高分：
    - 第1学期：最高分90分
    - 第2学期：最高分85分
    - 第3学期：最高分95分
    - 平均最高分：(90 + 85 + 95) / 3 = 90分
    """
    stats = {
        "top1_prob": top1_prob.mean(axis=1),  # token 级均值
        "margin": margin.mean(axis=1),        # token 级均值
        "entropy": entropy.mean(axis=1),      # token 级均值
    }

    return hard_vecs, soft_vecs, stats  # 返回


# ============================================================================
# Q2 注释补充总结
# ============================================================================
"""
========================================================================
Q2 任务偏好分析脚本 - 注释补充完成总结
========================================================================

【已完成的5个部分】：

Part 1: JSD（Jensen-Shannon Divergence）
- 详细的数学公式推导
- 完整的数值示例
- 零基础友好的解释

Part 2: TV 距离、集中度分数、Top-k 覆盖率
- TV 距离的计算方法
- 集中度分数的含义
- Top-k 覆盖率曲线的解释

Part 3: Hard/Soft 口径的概念
- 两种口径的对比
- 为什么需要两种口径
- 数学公式详解

Part 4: Hard 口径的实现
- Top-1 专家提取
- Margin 和熵的计算
- Hard 计票的代码实现

Part 5: Soft 口径的实现
- Top-(K+2) 概率累加
- 向量归一化
- 置信度统计

【核心概念总结】：

1. **Hard 口径**：
   - 每层只看 Top-1 专家
   - 简单、直观
   - 可能丢失信息

2. **Soft 口径**：
   - 考虑 Top-(K+2) 的概率分布
   - 更全面
   - 依赖概率估计的准确性

3. **任务偏好（Task Specialization）**：
   - 不同任务是否偏好不同专家？
   - 用 JSD/TV 衡量任务分布差异
   - 用 TSS 衡量任务偏离全局的程度

4. **置信度特征**：
   - Top-1 概率：路由的最高概率
   - Margin：Top-1 与 Top-2 的差值
   - 熵：路由分布的不确定性

【注释特点】：
✅ 数学公式详解（逐步推导）
✅ 零基础友好（生活化类比）
✅ 代码详细注释（逐行解释）
✅ 设计理由（为什么这样做）
✅ 数值示例（具体计算过程）

【下一步】：
开始 Q4/Q5/Q6 的注释补充。
"""


# ============================================================================
# Q2 的5个部分全部完成！
# ============================================================================
