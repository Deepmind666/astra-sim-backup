#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ============================================================================
# Q2 任务偏好分析脚本 - 详细注释补充（第4部分）
# Hard/Soft 口径的具体实现代码
# ============================================================================

"""
========================================================================
本部分详细解释 Hard 和 Soft 口径的代码实现
========================================================================
"""

        # ================================================================
        # 步骤2.3：提取 Top-1 专家（Hard 口径的基础）
        # ================================================================
        """
        【Top-1 专家提取】：
        找到每个 token 在该层的 Top-1 专家。

        【代码详解】：
        top1_idx = np.argmax(probs, axis=1)

        【np.argmax 的作用】：
        返回每行最大值的索引。

        【示例】：
        probs = array([[0.6, 0.3, 0.1],   # token 0
                       [0.2, 0.5, 0.3],   # token 1
                       [0.1, 0.2, 0.7]])  # token 2

        top1_idx = np.argmax(probs, axis=1) = [0, 1, 2]
        - token 0：最大值在位置0（0.6）
        - token 1：最大值在位置1（0.5）
        - token 2：最大值在位置2（0.7）

        【给零基础同学的解释】：
        想象你要找每个学生的最高分科目：
        - 学生A：数学90分，物理85分，化学80分 → 最高分：数学（位置0）
        - 学生B：数学70分，物理95分，化学75分 → 最高分：物理（位置1）
        """
        top1_idx = np.argmax(probs, axis=1)  # Top-1 在 Top-(K+2) 内的位置

        """
        【提取 Top-1 专家编号】：
        top1 = inds[np.arange(n_tokens), top1_idx]

        【高级索引详解】：
        这是 NumPy 的"花式索引"（Fancy Indexing）。

        【逐步拆解】：
        1. np.arange(n_tokens)：生成行索引 [0, 1, 2, ...]
        2. top1_idx：列索引 [0, 1, 2]（上面计算的）
        3. inds[行索引, 列索引]：提取对应位置的值

        【示例】：
        inds = array([[5, 8, 12],    # token 0 的专家索引
                      [12, 5, 20],   # token 1 的专家索引
                      [8, 12, 5]])   # token 2 的专家索引

        top1_idx = [0, 1, 2]

        top1 = inds[np.arange(3), top1_idx]
             = inds[[0, 1, 2], [0, 1, 2]]
             = [inds[0,0], inds[1,1], inds[2,2]]
             = [5, 5, 5]

        【给零基础同学的解释】：
        想象你有一个成绩表：
        - 学生A的科目：[数学, 物理, 化学]，对应编号：[5, 8, 12]
        - 学生A的最高分在位置0（数学）
        - 所以学生A的最高分科目编号是 5

        这行代码就是"批量提取每个学生的最高分科目编号"。
        """
        top1 = inds[np.arange(n_tokens), top1_idx]  # Top-1 专家编号

        """
        【提取 Top-1 概率】：
        top1_p = probs[np.arange(n_tokens), top1_idx]

        【示例】：
        probs = array([[0.6, 0.3, 0.1],
                       [0.2, 0.5, 0.3],
                       [0.1, 0.2, 0.7]])
        top1_idx = [0, 1, 2]

        top1_p = probs[[0, 1, 2], [0, 1, 2]]
               = [0.6, 0.5, 0.7]

        【给零基础同学的解释】：
        提取每个学生的最高分数值。
        """
        top1_p = probs[np.arange(n_tokens), top1_idx]  # Top-1 概率
        top1_prob[:, li] = top1_p  # 记录到统计矩阵

        # ================================================================
        # 步骤2.4：计算 Margin（Top-1 与 Top-2 的差值）
        # ================================================================
        """
        【什么是 Margin？】
        Margin = Top-1 概率 - Top-2 概率

        【为什么要计算 Margin？】
        Margin 衡量"路由决策的置信度"：
        - Margin 大：Top-1 远高于 Top-2，决策很确定
        - Margin 小：Top-1 接近 Top-2，决策不确定

        【示例】：
        情况1（高置信度）：
        - Top-1：0.8
        - Top-2：0.1
        - Margin：0.8 - 0.1 = 0.7（很确定）

        情况2（低置信度）：
        - Top-1：0.4
        - Top-2：0.35
        - Margin：0.4 - 0.35 = 0.05（不确定）

        【给零基础同学的解释】：
        想象你要选择最喜欢的科目：
        - 情况1：数学90分，物理60分 → 差距30分，很确定选数学
        - 情况2：数学85分，物理83分 → 差距2分，不太确定
        """
        if probs.shape[1] > 1:  # 如果有 Top-2
            """
            【提取 Top-2 概率】：
            sorted_probs = np.sort(probs, axis=1)：按行排序
            top2_p = sorted_probs[:, -2]：取倒数第2个（Top-2）

            【示例】：
            probs = array([[0.6, 0.3, 0.1],
                           [0.2, 0.5, 0.3]])

            sorted_probs = array([[0.1, 0.3, 0.6],  # 升序排序
                                  [0.2, 0.3, 0.5]])

            top2_p = sorted_probs[:, -2] = [0.3, 0.3]
            （倒数第2个就是 Top-2）

            【给零基础同学的解释】：
            想象你要找第二高分：
            - 成绩：[90, 85, 80]
            - 排序：[80, 85, 90]
            - 倒数第2个：85（第二高分）
            """
            sorted_probs = np.sort(probs, axis=1)  # 排序
            top2_p = sorted_probs[:, -2]  # 取 Top-2 概率
            margin[:, li] = top1_p - top2_p  # 计算 Margin

        # ================================================================
        # 步骤2.5：计算熵（衡量不确定性）
        # ================================================================
        """
        【什么是熵？】
        熵衡量概率分布的"不确定性"。

        【熵的公式】：
        H(p) = -Σ p(i) * log(p(i))

        【熵的含义】：
        - 熵高：分布均匀，不确定性大
        - 熵低：分布集中，不确定性小

        【示例】：
        情况1（低熵，确定）：
        p = [0.9, 0.05, 0.05]
        H(p) = -(0.9*log(0.9) + 0.05*log(0.05) + 0.05*log(0.05))
        H(p) ≈ 0.57（低熵）

        情况2（高熵，不确定）：
        p = [0.33, 0.33, 0.34]
        H(p) = -(0.33*log(0.33) + 0.33*log(0.33) + 0.34*log(0.34))
        H(p) ≈ 1.58（高熵）

        【给零基础同学的解释】：
        想象你要猜测掷骰子的结果：
        - 如果骰子是均匀的：每个面概率1/6，不确定性高（熵高）
        - 如果骰子被做了手脚：某个面概率90%，不确定性低（熵低）
        """
        entropy[:, li] = _entropy(probs_norm)  # 计算熵

        # ================================================================
        # 步骤2.6：Hard 口径计票（Top-1 专家 +1）
        # ================================================================
        """
        【Hard 口径的核心逻辑】：
        每层只看 Top-1 专家，给该专家 +1 票。

        【代码详解】：
        np.add.at(hard_vecs, (行索引, 列索引), 增量)

        【np.add.at 的作用】：
        在指定位置累加值（支持重复索引）。

        【为什么用 np.add.at 而不是直接赋值？】
        因为可能有重复索引：
        - 如果 token 0 和 token 1 都选择专家5
        - 直接赋值会覆盖
        - np.add.at 会累加

        【示例】：
        假设有 3 个 token，60 个专家：
        - token 0：Top-1 = 专家5
        - token 1：Top-1 = 专家12
        - token 2：Top-1 = 专家5

        执行：
        np.add.at(hard_vecs, ([0, 1, 2], [5, 12, 5]), 1.0)

        结果：
        hard_vecs[0, 5] += 1.0  # token 0 给专家5投票
        hard_vecs[1, 12] += 1.0  # token 1 给专家12投票
        hard_vecs[2, 5] += 1.0  # token 2 给专家5投票

        【给零基础同学的解释】：
        想象你要统计学生的主修科目：
        - 学生A：主修数学 → 数学 +1 票
        - 学生B：主修物理 → 物理 +1 票
        - 学生C：主修数学 → 数学 +1 票

        最终统计：数学2票，物理1票
        """
        valid_top1 = top1 >= 0  # Top-1 合法标记（排除 -1）
        if np.any(valid_top1):  # 如果存在合法的 Top-1
            np.add.at(
                hard_vecs,
                (np.arange(n_tokens)[valid_top1], top1[valid_top1]),
                1.0
            )  # Hard 计票


# ============================================================================
# 第4部分完成
# ============================================================================
# 下一部分将包含：
# - Soft 口径的具体实现（概率累加）
# - 向量归一化（除以层数）
# - 置信度统计的返回
# ============================================================================
