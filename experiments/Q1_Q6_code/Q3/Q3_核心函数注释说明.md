# Q3: 任务内路由模式分析 - 核心函数注释说明

## 文件信息
- **对应脚本**: `q3_extract_data.py`、`q3_generate_q3_figures.py`、`q3_generate_q3_figures_agg.py`、`q3_generate_q3_figures_from_json.py`
- **行号说明**: 早期版本是单脚本，这里记录的行号仅作理解辅助，实际行号以当前脚本为准
- **核心问题**: 任务内部的路由动态是否存在"粘滞性"或"阶段切换"现象

## 实验结论
- 6个任务切换率都很高(94%-97%)
- Run Length 与几何分布高度吻合
- 窗口漂移很弱,接近置乱基线
- **结论**: 任务内部路由近似无记忆,不存在粘滞或阶段切换

---

## 核心指标1: 切换率 (Switch Rate)

### 函数: `compute_switch_rate()`
**位置**: 第885-937行

**定义**: 相邻 token 切换专家的比例

**公式**:
```
Switch_Rate = Σ 1[Top1_t ≠ Top1_{t+1}] / (N-1)
```

**含义**:
- 切换率高(如 0.95) → 几乎每个 token 都在切换专家,粘滞性弱
- 切换率低(如 0.50) → 连续 token 倾向选同一专家,粘滞性强

**算法流程**:
1. 初始化计数器(switches=0, total=0)
2. 遍历每个样本段(segment)
3. 比较相邻 token 的 Top-1 是否不同
4. 累加切换次数和总 token 对数
5. 计算切换率 = 切换次数 / 总 token 对数

**注意事项**:
- 不跨样本边界计算,因为不同样本之间的切换没有意义

---

## 核心指标2: Run Length (连续段长度)

### 函数: `compute_run_lengths()`
**位置**: 第944-1001行

**定义**: Run Length = 连续选择同一专家的 token 数量

**示例**:
```
Top1 序列: [3, 3, 3, 5, 5, 2, 2, 2, 2]
Run Lengths: [3, 2, 4]
解释: 专家3连续3次, 专家5连续2次, 专家2连续4次
```

**理论基线**:
- 如果路由是"无记忆"的(每次独立选择),Run Length 应服从几何分布
- 几何分布: P(Run=k) = (1-p)^(k-1) * p,其中 p = 切换率
- 期望: E[Run] = 1/p

**算法流程**:
1. 初始化 run length 列表
2. 遍历每个样本段
3. 遍历序列,统计连续相同专家的长度
4. 当专家切换时,记录当前 run 并重置计数器
5. 记录最后一个 run

### 函数: `geometric_pmf()`
**位置**: 第1030-1055行

**公式**: P(X=k) = (1-p)^(k-1) * p

**含义**:
- X: Run Length 随机变量
- k: 具体的 run length 值
- p: 切换率

### 函数: `ks_test_geometric()`
**位置**: 第1058-1111行

**目的**: KS 检验 - Run Length 是否符合几何分布

**原理**:
- Kolmogorov-Smirnov 检验比较实测分布与理论分布的累积分布函数(CDF)
- D = max|F_实测(x) - F_理论(x)|

**假设检验**:
- H0(原假设): Run Length 服从几何分布(无记忆)
- H1(备择假设): Run Length 不服从几何分布

**判定标准**:
- p_value > 0.05 → 不能拒绝 H0 → 支持"无记忆"假设
- p_value < 0.05 → 拒绝 H0 → 存在记忆/粘滞性

---

## 核心指标3: 窗口漂移 (Window Drift)

### 函数: `compute_window_drift()`
**位置**: 第1118-1199行

**原理**:
- 将 token 序列划分为滑动窗口,计算相邻窗口的分布差异
- JSD/TV 大 → 分布变化剧烈(阶段切换)
- JSD/TV 小 → 分布稳定(无阶段切换)

**参数说明**:
- `window_size`: 窗口大小(如 64/128/256)
- `stride`: 滑动步长
- `use_other_bucket`: 是否使用 Other 桶(处理概率和 < 1 的情况)

**算法流程**:
1. 初始化分布列表
2. 为每个窗口构建专家分布
   - 遍历每个样本段
   - 滑动窗口从样本起始位置开始,每次移动 stride
   - 构建窗口分布(方案A: 平均分布 或 方案B: Top-1频率)
3. 计算相邻窗口的 JSD/TV 距离
4. 返回 (jsd_list, tv_list, distributions)

---

## 边界检测

### 函数: `detect_boundaries()` (规则方法)
**位置**: 第1206-1243行

**目的**: 找到任务内部的语义边界,如问题→答案的切换点

**方法**: 使用预定义的标记词(如 "####", "Answer" 等)

**边界标记词典**:
```python
DEFAULT_MARKERS = {
    "gsm8k": [r"####", r"Answer", r"答案", r"最终"],  # 数学推理
    "piqa": [r"A)", r"B)", r"(A)", r"(B)"],  # 常识问答
    "cmrc2018": [r"问题", r"答案"],  # 中文阅读理解
    "humaneval": [r"def ", r"return"],  # 代码生成
}
```

### 函数: `detect_boundaries_data_driven()` (数据驱动方法)
**位置**: 第1246-1325行

**目的**: 当 tokens_str 缺失时的备选方案

**方法**: 找到 JSD 曲线的峰值,作为可能的边界位置

**算法流程**:
1. 计算 JSD 阈值(如 90% 分位数)
2. 找到所有超过阈值的峰值
3. 按 JSD 降序排序
4. 去除距离太近的峰值(避免聚集)
5. 返回 Top-N 个峰值位置

### 函数: `compute_boundary_effect()`
**位置**: 第783-853行

**目的**: 验证语义边界是否真的导致专家分布跳变

**方法**: 比较边界处的漂移与随机位置的漂移

**假设检验**:
- H0(原假设): 边界处的漂移 = 随机位置的漂移(无特殊效应)
- H1(备择假设): 边界处的漂移 > 随机位置的漂移(存在阶段切换)

**算法流程**:
1. 筛选有效边界(边界两侧都有足够空间放置窗口)
2. 计算每个边界左右窗口的分布差异(JSD/TV)
3. 随机采样 n_random 个位置,计算其左右窗口的分布差异
4. 比较边界漂移与随机漂移的统计差异

---

## 置乱基线 (Shuffle Baseline)

### 函数: `shuffle_within_segments()`
**位置**: 第860-882行

**原理**:
- 保持边际分布不变(每个专家的总使用量不变)
- 只破坏时序关系(相邻 token 的依赖被打破)

**用途**:
- 如果实测切换率 ≈ 置乱切换率,说明路由本身就是随机的
- 如果实测切换率 < 置乱切换率,说明存在粘滞性

**示例**:
```
原始序列: [E3, E3, E5, E2, E2]
置乱后:   [E2, E5, E3, E2, E3]
- 每个专家的出现次数不变(E3:2次, E5:1次, E2:2次)
- 但相邻关系被打破(原本 E3-E3 连续,现在分散)
```

### 函数: `compute_shuffled_metrics()`
**位置**: 第885-936行

**流程**:
1. 生成置乱索引(segment 内部打乱)
2. 按置乱索引重排数据
3. 计算置乱后的切换率和窗口漂移

**判定逻辑**:
- 实测 ≈ 置乱 → 无时序效应(路由是随机的)
- 实测 < 置乱 → 存在粘滞性(连续 token 倾向选同一专家)
- 实测 > 置乱 → 异常(需检查数据或代码)

---

## Bootstrap 置信区间

### 函数: `bootstrap_ci()`
**位置**: 第942-985行

**目的**: 计算通用的 Bootstrap 置信区间

**算法步骤**:
1. 从原始 n 个样本中有放回地抽取 n 个样本
2. 计算该重采样的统计量(如均值)
3. 重复 B 次(如200次),得到 B 个统计量
4. 取第 2.5% 和 97.5% 分位数作为 95% 置信区间

**返回**: (均值, 置信区间下界, 置信区间上界)

### 函数: `bootstrap_switch_rate_ci()`
**位置**: 第988-1038行

**关键点**: 重采样单位是 segment,而非单个值

**为什么按 segment 重采样**:
- 同一样本内的 token 有依赖关系
- 如果按单个切换事件重采样,会破坏这种依赖
- 按 segment 重采样保持了样本的完整性

---

## 逐层分析

### 函数: `analyze_per_layer()`
**位置**: 第1075-1092行

**目的**: 分析每一层的切换率和 run length

**算法流程**:
1. 遍历每一层
2. 提取该层的 Top-1 专家序列
3. 计算该层的切换率
4. 计算该层的 run lengths
5. 返回每层的统计结果

**返回结果**:
```python
{
    "layer_0": {
        "switch_rate": 0.95,
        "run_mean": 1.05,
        "run_median": 1.0
    },
    ...
}
```

---

## 主函数流程

### 函数: `main()`
**位置**: 第1344-1670行

**完整工作流程**:

#### 第一部分: 参数解析和初始化
1. 解析命令行参数
2. 解析任务列表(task_name=path)
3. 解析窗口大小列表
4. 创建输出目录
5. 初始化随机数生成器

#### 第二部分: P0 数据结构检查(可选)
- 检查概率质量是否归一化
- 检查是否包含 tokens_str 字段
- 生成 `p0_data_structure_check.json`

#### 第三部分: 主分析循环(遍历每个任务)
1. **加载数据**
   - 调用 `load_task_data()` 加载 NPZ 文件
   - 提取 tokens, probs_by_layer, inds_by_layer, segments

2. **计算 Top-1 序列**
   - 调用 `get_token_top1()` 聚合所有层的专家选择

3. **核心指标1: 切换率 + Run Length**
   - 调用 `compute_switch_rate()` 计算切换率
   - 调用 `compute_run_lengths()` 计算 run lengths
   - 调用 `ks_test_geometric()` 进行 KS 检验

4. **核心指标2: 窗口漂移**
   - 调用 `compute_window_drift()` 计算相邻窗口的 JSD/TV 距离
   - 使用方案A(带 Other 桶)和方案B(Top-1 频率)

5. **置乱基线(可选)**
   - 调用 `compute_shuffled_metrics()` 计算置乱后的指标

6. **边界分析**
   - 调用 `detect_boundaries()` 检测语义边界(规则方法)
   - 如果失败,调用 `detect_boundaries_data_driven()` (数据驱动方法)
   - 调用 `compute_boundary_effect()` 比较边界处与随机位置的漂移

7. **Bootstrap 置信区间**
   - 调用 `bootstrap_ci()` 计算 JSD 的置信区间
   - 调用 `bootstrap_switch_rate_ci()` 计算切换率的置信区间
   - 调用 `bootstrap_run_mean_ci()` 计算 run mean 的置信区间

8. **逐层分析(可选)**
   - 调用 `analyze_per_layer()` 分析每一层的切换率

9. **窗口敏感性分析**
   - 对多个窗口大小(64/128/256)重复窗口漂移分析

#### 第四部分: 结果汇总和保存
1. 将所有任务的结果汇总到 `summary` 字典
2. 保存为 `task_drift_summary.json`

#### 第五部分: 可视化(生成图表)
1. **切换率对比图**: `plot_switch_rate_comparison()`
   - 实测 vs 置乱基线

2. **Run Length 分布图**: `plot_run_length_distribution()`
   - 实测分布 vs 几何分布基线

3. **窗口漂移曲线**: `plot_window_drift_curve()`
   - JSD 随窗口位置的变化

4. **边界对比图**: `plot_boundary_comparison()`
   - 边界处 vs 随机位置的漂移

5. **窗口敏感性图**: `plot_window_sensitivity()`
   - 不同窗口大小的 JSD 变化

6. **逐层热力图**: `plot_per_layer_heatmap()`
   - 每层的切换率热力图

---

## 关键数据结构

### 1. probs_by_layer
```python
{
    "layer_0": np.ndarray,  # 形状 [n_tokens, k], Top-K 概率
    "layer_1": np.ndarray,
    ...
}
```

### 2. inds_by_layer
```python
{
    "layer_0": np.ndarray,  # 形状 [n_tokens, k], Top-K 专家索引
    "layer_1": np.ndarray,
    ...
}
```

### 3. segments
```python
[
    (0, 512),      # 第一个样本: token 0-511
    (512, 1024),   # 第二个样本: token 512-1023
    ...
]
```

### 4. summary (输出结果)
```python
{
    "meta": {...},  # 命令行参数
    "tasks": {
        "gsm8k": {
            "n_tokens": 20000,
            "switch_rate": 0.95,
            "switch_rate_ci": [0.94, 0.96],
            "run_mean": 1.05,
            "run_mean_ci": [1.03, 1.07],
            "geometric_baseline_mean": 1.05,
            "ks_test": {
                "ks_statistic": 0.02,
                "p_value": 0.85,
                "reject_null": false
            },
            "window_jsd_mean": 0.015,
            "window_jsd_ci": [0.014, 0.016],
            "boundary_effect": {
                "n_boundaries": 10,
                "boundary_jsd_mean": 0.018,
                "random_jsd_mean": 0.015
            },
            ...
        },
        ...
    }
}
```

---

## 实验结论解读

### 1. 切换率分析
- **观察**: 6个任务切换率都很高(94%-97%)
- **解释**: 几乎每个 token 都在切换专家,说明粘滞性很弱
- **结论**: 不存在"连续多个 token 倾向选择相同专家"的现象

### 2. Run Length 分析
- **观察**: Run Length 与几何分布高度吻合
- **解释**: KS 检验的 p_value 都很高,不能拒绝原假设
- **结论**: 路由近似无记忆,每次选择都是独立的

### 3. 窗口漂移分析
- **观察**: 窗口漂移很弱,接近置乱基线
- **解释**: 相邻窗口的专家分布差异很小,且与置乱后的差异相当
- **结论**: 不存在明显的阶段切换

### 4. 边界效应分析
- **观察**: 边界处的漂移 ≈ 随机位置的漂移
- **解释**: 语义边界(如问题→答案)并未导致专家分布跳变
- **结论**: 专家选择与语义结构无关

### 5. 总结论
**任务内部路由近似无记忆,不存在粘滞或阶段切换**
- 路由是"无状态"的,每个 token 独立选择专家
- 专家选择不受前文影响,也不受语义边界影响
- 这与 Q2 的结论一致:专家分工主要体现在任务间,而非任务内

---

## 与其他问题的关联

### Q2: 任务专属性分析
- Q2 发现:不同任务有明显的专属专家
- Q3 发现:任务内部路由是随机的
- **结合**: 专家分工体现在任务级别,而非 token 级别

### Q4: 专家负载均衡
- Q3 的高切换率意味着专家使用频繁切换
- 这可能导致负载不均衡(某些专家被频繁调用)

### Q5: 专家协作模式
- Q3 的无记忆性说明专家之间缺乏协作
- 每层独立选择专家,不考虑前文的专家选择

---

## 代码运行示例

```bash
python analyze_task_drift_v2.py \
    --task gsm8k=/path/to/gsm8k \
    --task piqa=/path/to/piqa \
    --output_dir ./output \
    --window_sizes 64,128,256 \
    --bootstrap_runs 200 \
    --seed 42
```

**输出文件**:
- `p0_data_structure_check.json`: P0 检查结果
- `task_drift_summary.json`: 主分析结果
- `plots/q3_switch_rate_comparison.png`: 切换率对比图
- `plots/q3_run_length_analysis.png`: Run Length 分布图
- `plots/q3_window_drift_analysis.png`: 窗口漂移曲线
- `plots/q3_per_layer_heatmap.png`: 逐层热力图

---

## 注意事项

1. **短任务警告**: HumanEval 和 Winogrande 的 token 数量较少(<1000),结果可能不可靠

2. **窗口大小选择**:
   - 窗口太小(如32) → 噪声大
   - 窗口太大(如512) → 平滑过度,丢失细节
   - 推荐: 64/128/256

3. **Bootstrap 次数**:
   - 默认200次,可根据需要调整
   - 次数越多,置信区间越稳定,但计算时间越长

4. **边界检测**:
   - 优先使用规则方法(基于标记词)
   - 如果失败,自动切换到数据驱动方法(基于 JSD 峰值)

5. **置乱基线**:
   - 默认关闭,可通过 `--shuffle_baseline` 启用
   - 用于验证观察到的模式是否真实存在

---

**文档创建时间**: 2026-01-19
**作者**: Claude (基于李康锐的原始代码)
