#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ============================================================================
# Q6 负载集中度分析脚本 - 详细注释补充（第3部分）
# Lorenz 曲线
# ============================================================================

"""
========================================================================
本部分包含 Q6 的核心函数：
1. lorenz_curve：Lorenz 曲线
========================================================================
"""

# ============================================================================
# 核心函数：lorenz_curve（Lorenz 曲线）
# ============================================================================
def lorenz_curve(dist: np.ndarray) -> Tuple[List[float], List[float]]:
    """
    ========================================================================
    函数功能：计算 Lorenz 曲线（Lorenz Curve）
    ========================================================================

    【什么是 Lorenz 曲线？】
    Lorenz 曲线是一种可视化工具，用于展示分布的不均匀程度。

    【给零基础同学的解释】：
    想象你要画一条曲线，展示"财富分配的不平等"：
    - 横轴：人口累计占比（0% → 100%）
    - 纵轴：财富累计占比（0% → 100%）

    如果财富完全平等：
    - 前 20% 的人拥有 20% 的财富
    - 前 50% 的人拥有 50% 的财富
    - 曲线是一条对角线（45度）

    如果财富不平等：
    - 前 80% 的人只拥有 20% 的财富
    - 前 99% 的人拥有 50% 的财富
    - 曲线向下弯曲（远离对角线）

    【在 MoE 中的含义】：
    - 横轴：专家累计占比
    - 纵轴：负载累计占比
    - 曲线越弯曲 → 负载越集中

    【数学定义】：
    1. 将分布按升序排序
    2. 计算累计和
    3. 归一化到 [0, 1]

    【示例】：
    假设有 5 个专家，使用频次为：
    dist = [30, 10, 20, 5, 35]

    【逐步计算】：
    1. 升序排序：
       sorted_dist = [5, 10, 20, 30, 35]

    2. 归一化（转换为概率）：
       总和 = 5 + 10 + 20 + 30 + 35 = 100
       normalized = [0.05, 0.10, 0.20, 0.30, 0.35]

    3. 计算累计和：
       cumsum = [0.05, 0.15, 0.35, 0.65, 1.00]

    4. 构造 Lorenz 曲线：
       横坐标（专家累计占比）：
       x = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]
       （0%, 20%, 40%, 60%, 80%, 100%）

       纵坐标（负载累计占比）：
       y = [0.0, 0.05, 0.15, 0.35, 0.65, 1.00]
       （0%, 5%, 15%, 35%, 65%, 100%）

    【结果解释】：
    - 点 (0.2, 0.05)：前 20% 的专家（1个）承担 5% 的负载
    - 点 (0.4, 0.15)：前 40% 的专家（2个）承担 15% 的负载
    - 点 (0.6, 0.35)：前 60% 的专家（3个）承担 35% 的负载
    - 点 (0.8, 0.65)：前 80% 的专家（4个）承担 65% 的负载
    - 点 (1.0, 1.00)：所有专家承担 100% 的负载

    【可视化】：
    ```
    纵轴（负载累计占比）
    1.0 |                    ●
        |                 ●
    0.65|              ●
        |           ●
    0.35|        ●
        |     ●
    0.15|  ●
    0.05|●
    0.0 ●--------------------
        0.0  0.2  0.4  0.6  0.8  1.0
        横轴（专家累计占比）
    ```

    【与对角线的对比】：
    - 对角线（完全平等）：y = x
    - Lorenz 曲线：y < x（负载不平等）
    - 曲线越弯曲 → Gini 系数越大

    【给零基础同学的解释】：
    想象你要画一条曲线，展示"班级成绩分布"：
    - 横轴：学生累计占比（从成绩最低到最高）
    - 纵轴：总分累计占比

    如果成绩完全平等：
    - 前 50% 的学生贡献 50% 的总分
    - 曲线是一条对角线

    如果成绩不平等：
    - 前 80% 的学生只贡献 30% 的总分
    - 曲线向下弯曲（少数学生贡献大部分分数）

    【参数说明】：
    - dist: np.ndarray，专家使用分布

    【返回值】：
    - Tuple[List[float], List[float]]
      * 第一个列表：横坐标（专家累计占比）
      * 第二个列表：纵坐标（负载累计占比）
    """
    # ====================================================================
    # 步骤1：归一化
    # ====================================================================
    """
    【归一化】：
    values = safe_normalize(dist)

    【为什么要归一化？】
    确保分布和为 1，方便计算累计占比。

    【示例】：
    dist = [5, 10, 20, 30, 35]
    总和 = 100
    normalized = [0.05, 0.10, 0.20, 0.30, 0.35]

    【给零基础同学的解释】：
    想象你要把"使用次数"转换为"使用比例"。
    """
    values = safe_normalize(dist)

    # ====================================================================
    # 步骤2：升序排序
    # ====================================================================
    """
    【升序排序】：
    values = np.sort(values)

    【为什么要升序？】
    因为 Lorenz 曲线要求从"负载最小"到"负载最大"排列。

    【示例】：
    原始：[0.30, 0.10, 0.20, 0.05, 0.35]
    排序后：[0.05, 0.10, 0.20, 0.30, 0.35]

    【给零基础同学的解释】：
    想象你要按成绩从低到高排列学生。
    """
    values = np.sort(values)

    # ====================================================================
    # 步骤3：计算累计和
    # ====================================================================
    """
    【累计和】：
    cum = np.cumsum(values)

    【np.cumsum 的作用】：
    计算累计和（Cumulative Sum）。

    【示例】：
    values = [0.05, 0.10, 0.20, 0.30, 0.35]
    cum = np.cumsum(values)
    cum = [0.05, 0.15, 0.35, 0.65, 1.00]

    【逐步计算】：
    - cum[0] = 0.05（第1个专家的负载）
    - cum[1] = 0.05 + 0.10 = 0.15（前2个专家的负载）
    - cum[2] = 0.15 + 0.20 = 0.35（前3个专家的负载）
    - cum[3] = 0.35 + 0.30 = 0.65（前4个专家的负载）
    - cum[4] = 0.65 + 0.35 = 1.00（所有专家的负载）

    【给零基础同学的解释】：
    想象你要计算"前 N 个学生的总分"：
    - 前 1 个学生：5 分
    - 前 2 个学生：5 + 10 = 15 分
    - 前 3 个学生：15 + 20 = 35 分
    - ...
    """
    cum = np.cumsum(values)

    # ====================================================================
    # 步骤4：构造横坐标（专家累计占比）
    # ====================================================================
    """
    【构造横坐标】：
    x = np.linspace(0.0, 1.0, len(values) + 1)

    【np.linspace 的作用】：
    在 [0, 1] 区间生成均匀分布的点。

    【为什么是 len(values) + 1？】
    因为要包含起点 (0, 0)。

    【示例】：
    len(values) = 5
    x = np.linspace(0.0, 1.0, 6)
    x = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]

    【含义】：
    - x[0] = 0.0：0% 的专家
    - x[1] = 0.2：20% 的专家（1个）
    - x[2] = 0.4：40% 的专家（2个）
    - x[3] = 0.6：60% 的专家（3个）
    - x[4] = 0.8：80% 的专家（4个）
    - x[5] = 1.0：100% 的专家（5个）

    【给零基础同学的解释】：
    想象你要标记"前 N% 的学生"：
    - 0%：没有学生
    - 20%：前 1 个学生
    - 40%：前 2 个学生
    - ...
    - 100%：所有学生
    """
    x = np.linspace(0.0, 1.0, len(values) + 1)

    # ====================================================================
    # 步骤5：构造纵坐标（负载累计占比）
    # ====================================================================
    """
    【构造纵坐标】：
    y = np.concatenate(([0.0], cum))

    【为什么要加 [0.0]？】
    因为起点是 (0, 0)：0% 的专家承担 0% 的负载。

    【np.concatenate 的作用】：
    拼接数组。

    【示例】：
    cum = [0.05, 0.15, 0.35, 0.65, 1.00]
    y = np.concatenate(([0.0], cum))
    y = [0.0, 0.05, 0.15, 0.35, 0.65, 1.00]

    【含义】：
    - y[0] = 0.0：0% 的专家承担 0% 的负载
    - y[1] = 0.05：前 20% 的专家承担 5% 的负载
    - y[2] = 0.15：前 40% 的专家承担 15% 的负载
    - y[3] = 0.35：前 60% 的专家承担 35% 的负载
    - y[4] = 0.65：前 80% 的专家承担 65% 的负载
    - y[5] = 1.00：所有专家承担 100% 的负载

    【给零基础同学的解释】：
    想象你要标记"前 N% 的学生贡献的总分占比"：
    - 0% 的学生：贡献 0% 的总分
    - 前 20% 的学生：贡献 5% 的总分
    - 前 40% 的学生：贡献 15% 的总分
    - ...
    - 所有学生：贡献 100% 的总分
    """
    y = np.concatenate(([0.0], cum))

    # ====================================================================
    # 步骤6：转换为列表返回
    # ====================================================================
    """
    【转换为列表】：
    return x.tolist(), y.tolist()

    【返回值】：
    - x.tolist()：横坐标列表
    - y.tolist()：纵坐标列表

    【示例】：
    x = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]
    y = [0.0, 0.05, 0.15, 0.35, 0.65, 1.00]

    【如何使用】：
    可以用 matplotlib 画图：
    ```python
    import matplotlib.pyplot as plt
    x, y = lorenz_curve(dist)
    plt.plot(x, y, label='Lorenz Curve')
    plt.plot([0, 1], [0, 1], 'k--', label='Perfect Equality')
    plt.xlabel('Cumulative Share of Experts')
    plt.ylabel('Cumulative Share of Load')
    plt.legend()
    plt.show()
    ```

    【给零基础同学的解释】：
    想象你要画一条曲线：
    - 横坐标：[0%, 20%, 40%, 60%, 80%, 100%]
    - 纵坐标：[0%, 5%, 15%, 35%, 65%, 100%]
    - 连接这些点就是 Lorenz 曲线
    """
    return x.tolist(), y.tolist()


# ============================================================================
# Q6 Part 3 完成
# ============================================================================
# 已完成的内容：
# - Part 1: n_eff（熵口径和 Simpson 口径）
# - Part 2: Gini 系数和 Top-N 覆盖率
# - Part 3: Lorenz 曲线
#
# Q6 的核心负载集中度分析函数已经完成！
# ============================================================================
