#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ============================================================================
# Q6 负载集中度分析脚本 - 详细注释补充（第2部分）
# Gini 系数、Top-N 覆盖率、Lorenz 曲线
# ============================================================================

"""
========================================================================
本部分包含 Q6 的核心函数：
1. gini_coefficient：Gini 系数
2. top_n_coverage：Top-N 覆盖率
3. lorenz_curve：Lorenz 曲线
========================================================================
"""

# ============================================================================
# 核心函数：gini_coefficient（Gini 系数）
# ============================================================================
def gini_coefficient(dist: np.ndarray) -> float:
    """
    ========================================================================
    函数功能：计算 Gini 系数（Gini Coefficient）
    ========================================================================

    【什么是 Gini 系数？】
    Gini 系数用于衡量分布的"不均匀程度"，最初用于衡量收入不平等。

    【给零基础同学的解释】：
    想象你要衡量一个国家的"贫富差距"：
    - Gini = 0：所有人收入相同（完全平等）
    - Gini = 1：一个人拥有所有财富（完全不平等）

    在 MoE 中，Gini 系数衡量"专家负载的不均匀程度"：
    - Gini = 0：所有专家负载相同（完全均匀）
    - Gini = 1：一个专家承担所有负载（完全集中）

    【数学公式】：
    Gini = (2 * Σ i * x_i - (n+1) * Σ x_i) / (n * Σ x_i)

    其中：
    - x_i：排序后的第 i 个值（升序）
    - n：元素数量
    - i：索引（从 1 开始）

    【公式推导】：
    Gini 系数基于 Lorenz 曲线：
    - Lorenz 曲线：累计人口比例 vs 累计财富比例
    - Gini = 2 * (对角线下面积 - Lorenz 曲线下面积)

    【示例】：
    假设有 5 个专家，使用频次为：

    情况1（完全均匀）：
    dist = [20, 20, 20, 20, 20]（每个专家使用 20 次）

    【逐步计算】：
    1. 排序（升序）：
       sorted_dist = [20, 20, 20, 20, 20]

    2. 计算 Σ i * x_i：
       Σ i * x_i = 1*20 + 2*20 + 3*20 + 4*20 + 5*20
       Σ i * x_i = 20 + 40 + 60 + 80 + 100 = 300

    3. 计算 Σ x_i：
       Σ x_i = 20 + 20 + 20 + 20 + 20 = 100

    4. 计算 Gini：
       Gini = (2*300 - 6*100) / (5*100)
       Gini = (600 - 600) / 500 = 0

    【结果解释】：Gini = 0，完全均匀分布。

    情况2（高度集中）：
    dist = [1, 1, 1, 1, 96]（一个专家承担大部分负载）

    【逐步计算】：
    1. 排序（升序）：
       sorted_dist = [1, 1, 1, 1, 96]

    2. 计算 Σ i * x_i：
       Σ i * x_i = 1*1 + 2*1 + 3*1 + 4*1 + 5*96
       Σ i * x_i = 1 + 2 + 3 + 4 + 480 = 490

    3. 计算 Σ x_i：
       Σ x_i = 1 + 1 + 1 + 1 + 96 = 100

    4. 计算 Gini：
       Gini = (2*490 - 6*100) / (5*100)
       Gini = (980 - 600) / 500 = 0.76

    【结果解释】：Gini = 0.76，高度不均匀（接近完全集中）。

    情况3（中等不均匀）：
    dist = [10, 15, 20, 25, 30]

    【逐步计算】：
    1. 排序（升序）：
       sorted_dist = [10, 15, 20, 25, 30]

    2. 计算 Σ i * x_i：
       Σ i * x_i = 1*10 + 2*15 + 3*20 + 4*25 + 5*30
       Σ i * x_i = 10 + 30 + 60 + 100 + 150 = 350

    3. 计算 Σ x_i：
       Σ x_i = 10 + 15 + 20 + 25 + 30 = 100

    4. 计算 Gini：
       Gini = (2*350 - 6*100) / (5*100)
       Gini = (700 - 600) / 500 = 0.2

    【结果解释】：Gini = 0.2，中等不均匀。

    【给零基础同学的解释】：
    想象你要衡量班级成绩的"差距"：
    - 所有人都考 80 分 → Gini = 0（没有差距）
    - 一个人考 100 分，其他人都考 0 分 → Gini = 1（差距极大）
    - 成绩从 60 到 90 分均匀分布 → Gini ≈ 0.2（有差距但不大）

    【参数说明】：
    - dist: np.ndarray，专家使用分布（频次或概率）

    【返回值】：
    - float，Gini 系数，范围 [0, 1]
    """
    # ====================================================================
    # 步骤1：转换为 NumPy 数组
    # ====================================================================
    values = np.asarray(dist, dtype=np.float64)

    # ====================================================================
    # 步骤2：边界情况处理
    # ====================================================================
    """
    【边界情况】：
    if values.size == 0 or np.sum(values) == 0:
        return 0.0

    【为什么返回 0？】
    - 空数组：没有数据，无法计算
    - 总和为 0：所有值都是 0，视为"完全均匀"

    【给零基础同学的解释】：
    想象你要统计班级成绩差距：
    - 如果没有学生 → 无法计算
    - 如果所有人都考 0 分 → 没有差距（Gini = 0）
    """
    if values.size == 0 or np.sum(values) == 0:
        return 0.0

    # ====================================================================
    # 步骤3：排序（升序）
    # ====================================================================
    """
    【排序】：
    values = np.sort(values)

    【为什么要排序？】
    因为 Gini 系数的公式要求按升序排列。

    【示例】：
    原始：[30, 10, 20, 25, 15]
    排序后：[10, 15, 20, 25, 30]

    【给零基础同学的解释】：
    想象你要按成绩从低到高排列学生。
    """
    values = np.sort(values)

    # ====================================================================
    # 步骤4：计算 Gini 系数
    # ====================================================================
    """
    【Gini 公式】：
    Gini = (2 * Σ i * x_i - (n+1) * Σ x_i) / (n * Σ x_i)

    【代码实现】：
    n = len(values)
    cumsum = np.cumsum(values)
    return float((2 * np.sum((np.arange(1, n + 1) * values)) - (n + 1) * cumsum[-1]) / (n * cumsum[-1]))

    【逐步拆解】：
    1. n = len(values)：元素数量

    2. np.arange(1, n + 1)：生成索引 [1, 2, 3, ..., n]
       例如：n=5 → [1, 2, 3, 4, 5]

    3. np.arange(1, n + 1) * values：逐元素相乘
       例如：[1, 2, 3, 4, 5] * [10, 15, 20, 25, 30]
            = [10, 30, 60, 100, 150]

    4. np.sum(...)：求和
       例如：10 + 30 + 60 + 100 + 150 = 350

    5. cumsum = np.cumsum(values)：累计和
       例如：[10, 15, 20, 25, 30]
            → [10, 25, 45, 70, 100]

    6. cumsum[-1]：最后一个元素（总和）
       例如：100

    7. 代入公式：
       Gini = (2*350 - 6*100) / (5*100)
       Gini = (700 - 600) / 500 = 0.2

    【给零基础同学的解释】：
    想象你要计算"成绩差距"：
    - 先按成绩排序
    - 计算"加权总分"（排名越高，权重越大）
    - 用公式算出差距指数
    """
    n = len(values)
    cumsum = np.cumsum(values)
    return float((2 * np.sum((np.arange(1, n + 1) * values)) - (n + 1) * cumsum[-1]) / (n * cumsum[-1]))


# ============================================================================
# 核心函数：top_n_coverage（Top-N 覆盖率）
# ============================================================================
def top_n_coverage(dist: np.ndarray, n: int) -> float:
    """
    ========================================================================
    函数功能：计算 Top-N 覆盖率
    ========================================================================

    【什么是 Top-N 覆盖率？】
    Top-N 覆盖率表示"前 N 个最常用的专家，覆盖了多少比例的负载"。

    【给零基础同学的解释】：
    想象你有 60 个专家，统计每个专家的使用频次：
    - 专家5：使用了 30% 的时间
    - 专家12：使用了 20% 的时间
    - 专家8：使用了 15% 的时间
    - 其他 57 个专家：共使用了 35% 的时间

    Top-3 覆盖率 = 30% + 20% + 15% = 65%
    （前 3 个专家覆盖了 65% 的负载）

    【为什么需要 Top-N 覆盖率？】
    1. 衡量负载集中度：覆盖率高 → 负载集中
    2. 与 Gini 系数互证：两个指标应该一致
    3. 直观易懂：比 Gini 系数更容易解释

    【数学公式】：
    Coverage(N) = Σ (前 N 个最大的值) / Σ (所有值)

    【示例】：
    假设有 5 个专家，使用频次为：
    dist = [30, 10, 20, 5, 35]

    【逐步计算】：
    1. 降序排序：
       sorted_dist = [35, 30, 20, 10, 5]

    2. 计算 Top-3 覆盖率：
       Top-3 = 35 + 30 + 20 = 85
       总和 = 35 + 30 + 20 + 10 + 5 = 100
       Coverage(3) = 85 / 100 = 0.85（85%）

    3. 计算 Top-1 覆盖率：
       Top-1 = 35
       Coverage(1) = 35 / 100 = 0.35（35%）

    【结果解释】：
    - Top-1 覆盖率 = 35%：最常用的专家承担 35% 的负载
    - Top-3 覆盖率 = 85%：前 3 个专家承担 85% 的负载
    - 说明负载比较集中

    【给零基础同学的解释】：
    想象你要统计"前几名学生的总分占比"：
    - 班级总分：100 分
    - 第 1 名：35 分（占 35%）
    - 前 3 名：85 分（占 85%）
    - 说明前几名学生贡献了大部分分数

    【参数说明】：
    - dist: np.ndarray，专家使用分布
    - n: int，Top-N 的 N 值

    【返回值】：
    - float，Top-N 覆盖率，范围 [0, 1]
    """
    # ====================================================================
    # 步骤1：转换为 NumPy 数组
    # ====================================================================
    values = np.asarray(dist, dtype=np.float64)

    # ====================================================================
    # 步骤2：边界情况处理
    # ====================================================================
    if values.size == 0 or np.sum(values) == 0:
        return 0.0

    # ====================================================================
    # 步骤3：降序排序
    # ====================================================================
    """
    【降序排序】：
    sorted_vals = np.sort(values)[::-1]

    【为什么要降序？】
    因为我们要找"最大的 N 个值"。

    【[::-1] 的含义】：
    反转数组（从升序变成降序）。

    【示例】：
    values = [30, 10, 20, 5, 35]
    np.sort(values) = [5, 10, 20, 30, 35]（升序）
    np.sort(values)[::-1] = [35, 30, 20, 10, 5]（降序）

    【给零基础同学的解释】：
    想象你要按成绩从高到低排列学生。
    """
    sorted_vals = np.sort(values)[::-1]

    # ====================================================================
    # 步骤4：计算 Top-N 覆盖率
    # ====================================================================
    """
    【计算覆盖率】：
    Coverage = Σ (前 N 个值) / Σ (所有值)

    【代码实现】：
    return float(np.sum(sorted_vals[:n]) / np.sum(values))

    【逐步拆解】：
    1. sorted_vals[:n]：取前 N 个值
       例如：n=3 → [35, 30, 20]

    2. np.sum(sorted_vals[:n])：前 N 个值的和
       例如：35 + 30 + 20 = 85

    3. np.sum(values)：所有值的和
       例如：100

    4. 除法：85 / 100 = 0.85

    【给零基础同学的解释】：
    想象你要计算"前 3 名学生的总分占比"：
    - 前 3 名总分：85 分
    - 班级总分：100 分
    - 占比：85 / 100 = 85%
    """
    return float(np.sum(sorted_vals[:n]) / np.sum(values))


# ============================================================================
# Q6 Part 2 完成
# ============================================================================
# 下一部分将包含：
# - lorenz_curve 函数的详细注释
# - Lorenz 曲线的概念和可视化解释
# ============================================================================
